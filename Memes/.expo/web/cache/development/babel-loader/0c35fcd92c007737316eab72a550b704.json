{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _jsxFileName = \"D:\\\\React Native Project\\\\Memes\\\\node_modules\\\\react-native-parsed-text\\\\src\\\\ParsedText.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport ReactNative from \"react-native-web/dist/index\";\nimport PropTypes from 'prop-types';\nimport TextExtraction from \"./lib/TextExtraction\";\nvar PATTERNS = {\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)/i,\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\n  email: /\\S+@\\S+\\.\\S+/\n};\nvar defaultParseShape = PropTypes.shape(_objectSpread({}, ReactNative.Text.propTypes, {\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired\n}));\nvar customParseShape = PropTypes.shape(_objectSpread({}, ReactNative.Text.propTypes, {\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]).isRequired\n}));\n\nvar ParsedText = function (_React$Component) {\n  _inherits(ParsedText, _React$Component);\n\n  var _super = _createSuper(ParsedText);\n\n  function ParsedText() {\n    _classCallCheck(this, ParsedText);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ParsedText, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(nativeProps) {\n      this._root.setNativeProps(nativeProps);\n    }\n  }, {\n    key: \"getPatterns\",\n    value: function getPatterns() {\n      return this.props.parse.map(function (option) {\n        var type = option.type,\n            patternOption = _objectWithoutProperties(option, [\"type\"]);\n\n        if (type) {\n          if (!PATTERNS[type]) {\n            throw new Error(option.type + \" is not a supported type\");\n          }\n\n          patternOption.pattern = PATTERNS[type];\n        }\n\n        return patternOption;\n      });\n    }\n  }, {\n    key: \"getParsedText\",\n    value: function getParsedText() {\n      var _this = this;\n\n      if (!this.props.parse) {\n        return this.props.children;\n      }\n\n      if (typeof this.props.children !== 'string') {\n        return this.props.children;\n      }\n\n      var textExtraction = new TextExtraction(this.props.children, this.getPatterns());\n      return textExtraction.parse().map(function (props, index) {\n        return React.createElement(ReactNative.Text, _extends({\n          key: \"parsedText-\" + index\n        }, _this.props.childrenProps, props, {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 66,\n            columnNumber: 9\n          }\n        }));\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement(ReactNative.Text, _extends({\n        ref: function ref(_ref) {\n          return _this2._root = _ref;\n        }\n      }, this.props, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 77,\n          columnNumber: 7\n        }\n      }), this.getParsedText());\n    }\n  }]);\n\n  return ParsedText;\n}(React.Component);\n\nParsedText.displayName = 'ParsedText';\nParsedText.propTypes = _objectSpread({}, ReactNative.Text.propTypes, {\n  parse: PropTypes.arrayOf(PropTypes.oneOfType([defaultParseShape, customParseShape])),\n  childrenProps: PropTypes.shape(ReactNative.Text.propTypes)\n});\nParsedText.defaultProps = {\n  parse: null,\n  childrenProps: {}\n};\nexport default ParsedText;","map":{"version":3,"sources":["D:/React Native Project/Memes/node_modules/react-native-parsed-text/src/ParsedText.js"],"names":["React","ReactNative","PropTypes","TextExtraction","PATTERNS","url","phone","email","defaultParseShape","shape","Text","propTypes","type","oneOf","Object","keys","isRequired","customParseShape","pattern","oneOfType","string","instanceOf","RegExp","ParsedText","nativeProps","_root","setNativeProps","props","parse","map","option","patternOption","Error","children","textExtraction","getPatterns","index","childrenProps","ref","getParsedText","Component","displayName","arrayOf","defaultProps"],"mappings":"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","sourcesContent":["import React from 'react';\nimport ReactNative from 'react-native';\nimport PropTypes from 'prop-types';\n\nimport TextExtraction from './lib/TextExtraction';\n\nconst PATTERNS = {\n  url: /(https?:\\/\\/|www\\.)[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&\\/\\/=]*)/i,\n  phone: /[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,7}/,\n  email: /\\S+@\\S+\\.\\S+/,\n};\n\nconst defaultParseShape = PropTypes.shape({\n  ...ReactNative.Text.propTypes,\n  type: PropTypes.oneOf(Object.keys(PATTERNS)).isRequired,\n});\n\nconst customParseShape = PropTypes.shape({\n  ...ReactNative.Text.propTypes,\n  pattern: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(RegExp)]).isRequired,\n});\n\nclass ParsedText extends React.Component {\n\n  static displayName = 'ParsedText';\n\n  static propTypes = {\n    ...ReactNative.Text.propTypes,\n    parse: PropTypes.arrayOf(\n      PropTypes.oneOfType([defaultParseShape, customParseShape]),\n    ),\n    childrenProps: PropTypes.shape(ReactNative.Text.propTypes),\n  };\n\n  static defaultProps = {\n    parse: null,\n    childrenProps: {},\n  };\n\n  setNativeProps(nativeProps) {\n    this._root.setNativeProps(nativeProps);\n  }\n\n  getPatterns() {\n    return this.props.parse.map((option) => {\n      const {type, ...patternOption} = option;\n      if (type) {\n        if (!PATTERNS[type]) {\n          throw new Error(`${option.type} is not a supported type`);\n        }\n        patternOption.pattern = PATTERNS[type];\n      }\n\n      return patternOption;\n    });\n  }\n\n  getParsedText() {\n    if (!this.props.parse)                       { return this.props.children; }\n    if (typeof this.props.children !== 'string') { return this.props.children; }\n\n    const textExtraction = new TextExtraction(this.props.children, this.getPatterns());\n\n    return textExtraction.parse().map((props, index) => {\n      return (\n        <ReactNative.Text\n          key={`parsedText-${index}`}\n          {...this.props.childrenProps}\n          {...props}\n        />\n      );\n    });\n  }\n\n  render() {\n    return (\n      <ReactNative.Text\n        ref={ref => this._root = ref}\n        {...this.props}\n      >\n        {this.getParsedText()}\n      </ReactNative.Text>\n    );\n  }\n\n}\n\nexport default ParsedText;\n"]},"metadata":{},"sourceType":"module"}